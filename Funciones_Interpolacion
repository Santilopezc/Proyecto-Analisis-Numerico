import numpy as np
from sympy import symbols, expand

x = symbols('x')

def newton_interpolacion(x, y):
    """
    Calcula los coeficientes del polinomio de interpolación de Newton
    para el conjunto de datos (x, y) usando diferencias divididas.

    Args:
    x (list or numpy array): Coordenadas x de los datos.
    y (list or numpy array): Coordenadas y de los datos.

    Returns:
    numpy array: Tabla de diferencias divididas.
    """
    xm = np.array(list(map(float, x.split())) )
    ym = np.array(list(map(float, y.split())) )
    n = len(xm)
    tabla = np.zeros((n, n+1))
    tabla[:, 0] = xm
    tabla[:, 1] = ym

    # Llenar la tabla de diferencias divididas
    for j in range(2, n+1):
        for i in range(j-1, n):
            tabla[i, j] = (tabla[i, j-1] - tabla[i-1, j-1]) / (tabla[i, 0] - tabla[i-j+1, 0])

    return tabla



def construir_polinomio_newton(tabla, x_str):
    """
    Construye el polinomio de interpolación de Newton a partir de la tabla de diferencias divididas.

    Args:
    tabla (numpy array): Tabla de diferencias divididas.
    x_vals (list or numpy array): Coordenadas x de los datos.

    Returns:
    sympy expression: Polinomio de interpolación expandido.
    """

    x_vals = np.array(list(map(float, x_str.split())) )

    # Polinomio inicializado en el primer término
    n = len(x_vals)
    polinomio = tabla[0, 1]  # Primer coeficiente de diferencias divididas (f[x0])

    # Producto acumulativo de términos (x - x_vals[i])
    producto_acumulado = 1
    for j in range(2, n+1):
        producto_acumulado *= (x - x_vals[j - 2])
        polinomio += tabla[j-1, j] * producto_acumulado

    # Expandir el polinomio para obtener su forma final
    polinomio_expandido = expand(polinomio)
    return polinomio_expandido

from sympy import symbols, expand, simplify

def polinomio_lagrange(x_str, y_str):
    x = symbols('x')

    x_vals = np.array(list(map(float, x_str.split())) )
    y_vals = np.array(list(map(float, y_str.split())) )

    n = len(x_vals)
    polinomio = 0

    for i in range(n):
        # Calcular el polinomio base de Lagrange L_i(x)
        L_i = 1
        for j in range(n):
            if i != j:
                L_i *= (x - x_vals[j]) / (x_vals[i] - x_vals[j])


        # Sumar f(x_i) * L_i(x) al polinomio total
        polinomio += y_vals[i] * L_i

    # Expandir y simplificar el polinomio para obtener la forma final
    polinomio_expandido = expand(simplify(polinomio))
    return polinomio_expandido

def calcular_L_i(x_str, i, x_val_str):
    """
    Calcula el valor de L_i(x_val) para el polinomio de Lagrange en el índice i.

    Args:
    x_vals (list or numpy array): Coordenadas x de los puntos de datos.
    i (int): Índice del polinomio base L_i que queremos calcular.
    x_val (float): Valor de x en el que queremos evaluar L_i(x).

    Returns:
    float: Valor de L_i(x_val).
    """


    x_vals = np.array(list(map(float, x_str.split())) )
    x_val = float(x_val_str)

    
    L_i = 1

    # Construir L_i(x)
    for j in range(len(x_vals)):
        if j != i:
            L_i *= ( x - x_vals[j]) / (x_vals[i] - x_vals[j])

    # Evaluar L_i en x_val
    L_i_evaluado = L_i.subs(x, x_val)
    return L_i_evaluado
